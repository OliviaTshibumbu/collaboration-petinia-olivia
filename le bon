from kivymd.app import MDApp
from kivymd.uix.screen import MDScreen
from kivymd.uix.boxlayout import MDBoxLayout
from kivymd.uix.gridlayout import MDGridLayout
from kivymd.uix.scrollview import MDScrollView
from kivymd.uix.label import MDLabel
from kivymd.uix.textfield import MDTextField
from kivymd.uix.button import MDRaisedButton, MDIconButton, MDFloatingActionButton
from kivymd.uix.card import MDCard
from kivymd.uix.list import MDList, OneLineListItem, TwoLineListItem, ThreeLineListItem
from kivymd.uix.toolbar import MDTopAppBar
from kivymd.uix.screenmanager import MDScreenManager
from kivymd.uix.bottomnavigation import MDBottomNavigation, MDBottomNavigationItem
from kivymd.uix.dialog import MDDialog
from kivymd.uix.snackbar import Snackbar

from kivy.clock import Clock
from kivy.utils import platform
from kivy.storage.jsonstore import JsonStore
from kivy.network.urlrequest import UrlRequest

import os
import json
from datetime import datetime, timedelta
import threading
import random
import re
from collections import Counter


class StudyHelperApp(MDApp):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.title = "StudyHelper"
        
        # Configuration
        self.api_key = ""
        self.email_config = {
            'smtp_server': 'smtp.gmail.com',
            'smtp_port': 587,
            'email': '',
            'password': ''
        }
        
        # Données - CORRECTION 1: Initialisation propre
        self.notes_liste = []
        self.note_actuelle = None
        self.rappels_liste = []
        self.matieres = {}
        self.sessions_etude = []
        self.session_actuelle = None
        self.temps_debut_session = None
        self.notes_filtrees = []
        
        # Stockage
        self.store = None
        self.init_storage()
        
        # UI elements
        self.dialog = None
        self.menu = None
        
        # Quiz data
        self.quiz_questions = []
        self.quiz_actuel = None
        self.quiz_score = 0
        self.quiz_question_index = 0
        self.quiz_nombre_questions = 3  # Par défaut

    def build(self):
        """Construit l'interface principale"""
        self.theme_cls.primary_palette = "Blue"
        self.theme_cls.theme_style = "Light"
        
        # Screen Manager
        self.screen_manager = MDScreenManager()
        
        # Écran principal
        screen = MDScreen(name="main")
        
        # Layout principal
        main_layout = MDBoxLayout(orientation="vertical")
        
        # Toolbar
        toolbar = MDTopAppBar(
            title="StudyHelper",
            elevation=2
        )
        main_layout.add_widget(toolbar)
        
        # Bottom Navigation
        bottom_nav = MDBottomNavigation()
        
        # Onglet Notes
        notes_item = MDBottomNavigationItem(
            name="notes",
            text="Notes",
            icon="note-text"
        )
        notes_item.add_widget(self.create_notes_tab())
        bottom_nav.add_widget(notes_item)
        
        # Onglet Éditeur
        editor_item = MDBottomNavigationItem(
            name="editor", 
            text="Éditeur",
            icon="pencil"
        )
        editor_item.add_widget(self.create_editor_tab())
        bottom_nav.add_widget(editor_item)
        
        # Onglet Rappels
        reminders_item = MDBottomNavigationItem(
            name="reminders",
            text="Rappels", 
            icon="bell"
        )
        reminders_item.add_widget(self.create_reminders_tab())
        bottom_nav.add_widget(reminders_item)
        
        # Onglet Évolution
        evolution_item = MDBottomNavigationItem(
            name="evolution",
            text="Évolution",
            icon="chart-line"
        )
        evolution_item.add_widget(self.create_evolution_tab())
        bottom_nav.add_widget(evolution_item)
        
        main_layout.add_widget(bottom_nav)
        screen.add_widget(main_layout)
        self.screen_manager.add_widget(screen)
        
        return self.screen_manager

    def create_notes_tab(self):
        """Crée l'onglet des notes - CORRECTION AFFICHAGE"""
        layout = MDBoxLayout(orientation="vertical", padding="10dp", spacing="10dp")
        
        # Recherche
        self.search_field = MDTextField(
            hint_text="Rechercher...",
            size_hint_y=None,
            height="48dp"
        )
        self.search_field.bind(text=self.filter_notes)
        layout.add_widget(self.search_field)
        
        # Boutons
        buttons_layout = MDBoxLayout(
            orientation="horizontal",
            spacing="10dp", 
            size_hint_y=None,
            height="48dp"
        )
        
        new_note_btn = MDRaisedButton(text="Nouvelle Note")
        new_note_btn.bind(on_release=self.nouvelle_note)
        buttons_layout.add_widget(new_note_btn)
        
        clear_search_btn = MDRaisedButton(text="Effacer")
        clear_search_btn.bind(on_release=self.effacer_recherche)
        buttons_layout.add_widget(clear_search_btn)
        
        layout.add_widget(buttons_layout)
        
        # Liste des notes
        scroll = MDScrollView()
        self.notes_list = MDList()
        scroll.add_widget(self.notes_list)
        layout.add_widget(scroll)
        
        self.update_notes_list()
        return layout

    def create_editor_tab(self):
        """Crée l'onglet éditeur"""
        layout = MDBoxLayout(orientation="vertical", padding="10dp", spacing="10dp")
        
        # Titre
        self.title_field = MDTextField(
            hint_text="Titre de la note",
            size_hint_y=None,
            height="48dp"
        )
        layout.add_widget(self.title_field)
        
        # Contenu - CORRECTION SIMPLE POUR CONTENIR LE TEXTE
        content_card = MDCard(
            elevation=2,
            padding="10dp",
            size_hint_y=None,
            height="400dp"
        )
        
        # Scroll pour le contenu de l'éditeur
        content_scroll = MDScrollView()
        
        self.content_field = MDTextField(
            hint_text="Contenu de la note...",
            multiline=True,
            size_hint_y=None,
            height="350dp"  # Hauteur fixe pour éviter les débordements
        )
        
        content_scroll.add_widget(self.content_field)
        content_card.add_widget(content_scroll)
        layout.add_widget(content_card)
        
        # Boutons d'action
        buttons_layout = MDBoxLayout(
            orientation="horizontal",
            spacing="10dp",
            size_hint_y=None,
            height="48dp"
        )
        
        save_btn = MDRaisedButton(text="Sauvegarder")
        save_btn.bind(on_release=self.sauvegarder_note)
        buttons_layout.add_widget(save_btn)
        
        delete_btn = MDRaisedButton(text="Supprimer")
        delete_btn.bind(on_release=self.supprimer_note_dialog)
        buttons_layout.add_widget(delete_btn)
        
        share_btn = MDRaisedButton(text="Partager")
        share_btn.bind(on_release=self.partager_note_dialog)
        buttons_layout.add_widget(share_btn)
        
        layout.add_widget(buttons_layout)
        
        # Boutons outils
        tools_layout = MDBoxLayout(
            orientation="horizontal",
            spacing="10dp",
            size_hint_y=None,
            height="48dp"
        )
        
        quiz_btn = MDRaisedButton(text="Quiz")
        quiz_btn.bind(on_release=self.config_quiz_dialog)  # CORRECTION QUIZ
        tools_layout.add_widget(quiz_btn)
        
        resume_btn = MDRaisedButton(text="Résumé")
        resume_btn.bind(on_release=self.resumer_texte_intelligent) 
        tools_layout.add_widget(resume_btn)
        
        config_btn = MDRaisedButton(text="Config API")
        config_btn.bind(on_release=self.ouvrir_config_api)
        tools_layout.add_widget(config_btn)
        
        layout.add_widget(tools_layout)
        
        return layout

    def create_reminders_tab(self):
        """Crée l'onglet des rappels"""
        layout = MDBoxLayout(orientation="vertical", padding="10dp", spacing="10dp")
        
        # Titre
        title_label = MDLabel(
            text="Mes Rappels",
            theme_text_color="Primary",
            font_style="H5",
            size_hint_y=None,
            height="40dp"
        )
        layout.add_widget(title_label)
        
        # Bouton nouveau rappel
        add_btn = MDRaisedButton(
            text="Nouveau Rappel",
            size_hint_y=None,
            height="48dp"
        )
        add_btn.bind(on_release=self.ajouter_rappel_dialog)
        layout.add_widget(add_btn)
        
        # Liste des rappels
        scroll = MDScrollView()
        self.reminders_list = MDList()
        scroll.add_widget(self.reminders_list)
        layout.add_widget(scroll)
        
        self.update_reminders_list()
        return layout

    def create_evolution_tab(self):
        """Crée l'onglet évolution"""
        layout = MDBoxLayout(orientation="vertical", padding="10dp", spacing="10dp")
        
        # Session actuelle
        session_card = MDCard(
            elevation=2,
            padding="15dp",
            size_hint_y=None,
            height="120dp"
        )
        
        session_layout = MDBoxLayout(orientation="vertical", spacing="10dp")
        
        self.session_label = MDLabel(
            text="Aucune session active",
            theme_text_color="Primary",
            font_style="Subtitle1"
        )
        session_layout.add_widget(self.session_label)
        
        session_buttons = MDBoxLayout(
            orientation="horizontal",
            spacing="10dp",
            size_hint_y=None,
            height="48dp"
        )
        
        start_btn = MDRaisedButton(text="Démarrer Session")
        start_btn.bind(on_release=self.demander_nouvelle_session)
        session_buttons.add_widget(start_btn)
        
        stop_btn = MDRaisedButton(text="Terminer")
        stop_btn.bind(on_release=self.terminer_session_etude)
        session_buttons.add_widget(stop_btn)
        
        session_layout.add_widget(session_buttons)
        session_card.add_widget(session_layout)
        layout.add_widget(session_card)
        
        # Statistiques - MODIFICATION POUR INCLURE LES QUIZ
        stats_card = MDCard(
            elevation=2,
            padding="15dp",
            size_hint_y=None,
            height="200dp"  # Augmenté pour plus d'espace
        )
        
        stats_layout = MDBoxLayout(orientation="vertical", spacing="5dp")
        
        stats_title = MDLabel(text="Statistiques", font_style="H6")
        stats_layout.add_widget(stats_title)
        
        self.temps_label = MDLabel(text="Temps total: 0 min")
        self.sessions_label = MDLabel(text="Sessions: 0") 
        self.matieres_label = MDLabel(text="Matières: 0")
        # NOUVELLES LABELS POUR LES QUIZ
        self.quiz_total_label = MDLabel(text="Quiz réalisés: 0")
        self.quiz_moyenne_label = MDLabel(text="Moyenne quiz: 0%")
        
        stats_layout.add_widget(self.temps_label)
        stats_layout.add_widget(self.sessions_label)
        stats_layout.add_widget(self.matieres_label)
        stats_layout.add_widget(self.quiz_total_label)
        stats_layout.add_widget(self.quiz_moyenne_label)
        
        stats_card.add_widget(stats_layout)
        layout.add_widget(stats_card)
        
        # Liste matières
        subjects_scroll = MDScrollView()
        self.subjects_list = MDList()
        subjects_scroll.add_widget(self.subjects_list)
        layout.add_widget(subjects_scroll)
        
        # Boutons
        buttons_layout = MDBoxLayout(
            orientation="horizontal",
            spacing="10dp",
            size_hint_y=None,
            height="48dp"
        )
        
        associate_btn = MDRaisedButton(text="Associer Note")
        associate_btn.bind(on_release=self.associer_note_dialogue)
        buttons_layout.add_widget(associate_btn)
        
        stats_btn = MDRaisedButton(text="Statistiques")
        stats_btn.bind(on_release=self.afficher_statistiques)
        buttons_layout.add_widget(stats_btn)
        
        layout.add_widget(buttons_layout)
        
        self.update_evolution_panel()
        return layout

    # CORRECTION 1: Fonctions principales corrigées
    def nouvelle_note(self, *args):
        """Crée une nouvelle note - CORRIGÉ"""
        self.note_actuelle = None
        self.title_field.text = ""
        self.content_field.text = ""
        self.show_snackbar("Nouvelle note créée. Entrez le titre et le contenu.")

    def sauvegarder_note(self, *args):
        """Sauvegarde la note actuelle - CORRECTION MAJEURE"""
        titre = self.title_field.text.strip()
        contenu = self.content_field.text.strip()
        
        if not titre:
            self.show_snackbar("Le titre ne peut pas être vide!")
            return
        
        if self.note_actuelle:
            # Modification d'une note existante
            self.note_actuelle['titre'] = titre
            self.note_actuelle['contenu'] = contenu
            self.note_actuelle['date_modification'] = datetime.now().strftime("%Y-%m-%d %H:%M")
            self.enregistrer_activite('modification', f"Modification de {titre}")
            message = "Note modifiée avec succès!"
        else:
            # Nouvelle note - CORRECTION: génération d'ID unique
            nouveau_id = max([note['id'] for note in self.notes_liste], default=0) + 1
            
            nouvelle_note = {
                'id': nouveau_id,
                'titre': titre,
                'contenu': contenu,
                'date_creation': datetime.now().strftime("%Y-%m-%d %H:%M"),
                'tags': []
            }
            
            # CORRECTION: Ajouter à la liste ET définir comme note actuelle
            self.notes_liste.append(nouvelle_note)
            self.note_actuelle = nouvelle_note
            self.enregistrer_activite('creation', f"Création de {titre}")
            message = "Nouvelle note sauvegardée!"
        
        # Mettre à jour l'affichage et sauvegarder
        self.update_notes_list()
        self.save_data()
        self.show_snackbar(message)

    def update_notes_list(self):
        """Met à jour la liste des notes - CORRECTION AFFICHAGE"""
        if not hasattr(self, 'notes_list'):
            return
            
        self.notes_list.clear_widgets()
        
        # Utiliser les notes filtrées ou toutes les notes
        notes_a_afficher = self.notes_filtrees if self.notes_filtrees else self.notes_liste
        
        # Trier par date de création (plus récentes en premier)
        notes_triees = sorted(notes_a_afficher, 
                            key=lambda x: x.get('date_creation', ''), 
                            reverse=True)
        
        for note in notes_triees:
            # Affichage amélioré
            contenu_court = note['contenu'][:50] + "..." if len(note['contenu']) > 50 else note['contenu']
            date_affichage = note.get('date_creation', 'Inconnue')
            
            item = ThreeLineListItem(
                text=note['titre'],
                secondary_text=f"Créée: {date_affichage}",
                tertiary_text=contenu_court
            )
            item.bind(on_release=lambda x, note=note: self.select_note(note))
            self.notes_list.add_widget(item)

    def select_note(self, note):
        """Sélectionne une note - CORRECTION AFFICHAGE"""
        self.note_actuelle = note
        self.title_field.text = note['titre']
        self.content_field.text = note['contenu']
        self.enregistrer_activite('lecture', f"Lecture de {note['titre']}")
        
        # Créer un dialog pour afficher la note complète
        self.afficher_note_complete(note)

    def afficher_note_complete(self, note):
        """Affiche la note complète avec meilleur formatage - CORRECTION AFFICHAGE"""
        content = MDBoxLayout(
            orientation="vertical", 
            spacing="15dp", 
            adaptive_height=True,
            size_hint_y=None
        )
        content.bind(minimum_height=content.setter('height'))
        
        # Informations de la note
        info_text = f"Créée: {note.get('date_creation', 'Inconnue')}"
        if note.get('date_modification'):
            info_text += f"\nModifiée: {note['date_modification']}"
        
        info_label = MDLabel(
            text=info_text,
            font_style="Caption",
            theme_text_color="Secondary",
            size_hint_y=None,
            height="40dp"
        )
        content.add_widget(info_label)
        
        # Contenu de la note avec scroll intégré si nécessaire
        contenu_scroll = MDScrollView(
            size_hint=(1, None),
            height="300dp"  # Hauteur fixe pour éviter débordement
        )
        
        contenu_label = MDLabel(
            text=note['contenu'],
            font_style="Body1",
            text_size=(None, None),
            valign="top",
            markup=True,
            size_hint_y=None
        )
        # Calculer la hauteur nécessaire pour le texte
        contenu_label.text_size = (280, None)  # Largeur fixe
        contenu_label.bind(texture_size=contenu_label.setter('size'))
        
        contenu_scroll.add_widget(contenu_label)
        content.add_widget(contenu_scroll)
        
        self.dialog = MDDialog(
            title=note['titre'],
            type="custom",
            content_cls=content,
            size_hint=(0.9, 0.8),  # Limiter la taille du dialog
            buttons=[
                MDRaisedButton(text="Modifier", on_release=lambda x: self.modifier_note_actuelle()),
                MDRaisedButton(text="Fermer", on_release=self.close_dialog)
            ]
        )
        self.dialog.open()

    def modifier_note_actuelle(self):
        """Charge la note actuelle dans l'éditeur"""
        self.close_dialog()
        # La note est déjà chargée dans les champs par select_note
        self.show_snackbar(f"Note '{self.note_actuelle['titre']}' chargée dans l'éditeur")

    # CORRECTION 2: Fonction résumé intelligente
    def resumer_texte_intelligent(self, *args):
        """Résumé intelligent avec meilleur affichage - CORRECTION AFFICHAGE"""
        if not self.note_actuelle:
            self.show_snackbar("Sélectionnez une note à résumer!")
            return
        
        contenu = self.note_actuelle['contenu']
        
        if len(contenu) < 100:
            self.show_snackbar("Note trop courte pour être résumée")
            return
        
        resume = self.generer_resume_basique(contenu)
        
        content = MDBoxLayout(
            orientation="vertical", 
            spacing="15dp", 
            adaptive_height=True,
            size_hint_y=None
        )
        content.bind(minimum_height=content.setter('height'))
        
        stats_label = MDLabel(
            text=f"Note originale: {len(contenu.split())} mots\nRésumé: {len(resume.split())} mots",
            font_style="Caption",
            theme_text_color="Secondary",
            size_hint_y=None,
            height="40dp"
        )
        content.add_widget(stats_label)
        
        # Résumé dans un scroll pour éviter débordement
        resume_scroll = MDScrollView(
            size_hint=(1, None),
            height="300dp"
        )
        
        resume_label = MDLabel(
            text=resume,
            font_style="Body1",
            text_size=(None, None),
            valign="top",
            markup=True,
            size_hint_y=None
        )
        resume_label.text_size = (280, None)
        resume_label.bind(texture_size=resume_label.setter('size'))
        
        resume_scroll.add_widget(resume_label)
        content.add_widget(resume_scroll)
        
        self.dialog = MDDialog(
            title=f"Résumé: {self.note_actuelle['titre']}",
            type="custom",
            content_cls=content,
            size_hint=(0.9, 0.8),
            buttons=[MDRaisedButton(text="Fermer", on_release=self.close_dialog)]
        )
        self.dialog.open()

    def generer_resume_basique(self, texte):
        """Génère un résumé basique en extrayant les phrases importantes"""
        phrases = re.split(r'[.!?]+', texte)
        phrases = [p.strip() for p in phrases if len(p.strip()) > 20]
        
        if len(phrases) <= 3:
            return texte[:200] + "..." if len(texte) > 200 else texte
        
        # Prendre la première phrase, une du milieu, et une de la fin
        indices = [0, len(phrases)//2, -1]
        phrases_importantes = [phrases[i] for i in indices if i < len(phrases)]
        
        resume = '. '.join(phrases_importantes) + '.'
        
        # Limiter à 150 mots maximum
        mots_resume = resume.split()
        if len(mots_resume) > 150:
            resume = ' '.join(mots_resume[:150]) + '...'
        
        return resume

    # === NOUVELLES MÉTHODES POUR LE QUIZ CORRIGÉ ===
    
    def extraire_mots_cles(self, texte):
        """Extrait les mots-clés du texte"""
        mots = re.findall(r'\b\w{4,}\b', texte.lower())
        # Supprimer les mots communs
        mots_communs = {'dans', 'avec', 'pour', 'cette', 'sont', 'peut', 'plus', 'mais', 'tout', 'tous', 'leur', 'bien', 'aussi', 'très', 'encore', 'même', 'grand', 'comme', 'donc', 'depuis'}
        mots_filtres = [mot for mot in mots if mot not in mots_communs]
        
        # Retourner les mots les plus fréquents
        compteur = Counter(mots_filtres)
        return [mot for mot, freq in compteur.most_common(10)]

    def identifier_themes(self, texte, phrases):
        """Identifie les thèmes principaux"""
        themes = []
        mots_cles = self.extraire_mots_cles(texte)
        
        # Grouper les mots-clés par thèmes potentiels
        for mot in mots_cles[:5]:  # Top 5 mots-clés
            theme_phrases = [p for p in phrases if mot in p.lower()]
            if theme_phrases:
                themes.append({
                    'mot_cle': mot,
                    'phrases': theme_phrases[:2]  # Maximum 2 phrases par thème
                })
        
        return themes

    def extraire_definitions(self, texte):
        """Extrait les définitions du texte"""
        definitions = []
        phrases = re.split(r'[.!?]+', texte)
        
        for phrase in phrases:
            # Chercher des patterns de définition
            if any(pattern in phrase.lower() for pattern in ['est un', 'est une', 'désigne', 'correspond à', 'signifie']):
                parts = phrase.split(':')
                if len(parts) == 2:
                    definitions.append({
                        'terme': parts[0].strip(),
                        'definition': parts[1].strip()
                    })
                else:
                    # Pattern simple : "X est Y"
                    if ' est ' in phrase.lower():
                        parts = phrase.lower().split(' est ')
                        if len(parts) == 2:
                            definitions.append({
                                'terme': parts[0].strip(),
                                'definition': parts[1].strip()
                            })
        
        return definitions[:3]  # Maximum 3 définitions

    def extraire_concepts_importants(self, texte):
        """Extrait les concepts importants"""
        concepts = []
        mots_cles = self.extraire_mots_cles(texte)
        
        # Chercher des concepts avec des mots en majuscules ou des termes techniques
        mots_texte = texte.split()
        for mot in mots_texte:
            if (len(mot) > 3 and 
                (mot[0].isupper() or 
                 mot.lower() in mots_cles)):
                concepts.append(mot.strip('.,!?:;'))
        
        # Supprimer doublons et garder les plus pertinents
        concepts_uniques = list(set(concepts))
        return concepts_uniques[:8]

    def question_existe_deja(self, nouvelle_question, questions_existantes):
        """Vérifie si une question similaire existe déjà"""
        nouveau_texte = nouvelle_question['question'].lower()
        
        for question in questions_existantes:
            if question['question'].lower() == nouveau_texte:
                return True
            # Vérifier similarité basique
            mots_nouveau = set(nouveau_texte.split())
            mots_existant = set(question['question'].lower().split())
            
            intersection = len(mots_nouveau & mots_existant)
            union = len(mots_nouveau | mots_existant)
            
            if union > 0 and intersection / union > 0.7:  # 70% de similarité
                return True
        
        return False

    # === GÉNÉRATEURS DE QUESTIONS INTELLIGENTES ===
    
    def question_definition_concept(self, definitions, mots_cles):
        """Génère une question sur une définition"""
        if not definitions:
            return None
        
        definition = random.choice(definitions)
        fausses_definitions = [
            "Une méthode d'analyse",
            "Un processus complexe", 
            "Un élément fondamental"
        ]
        
        options = [definition['definition']] + fausses_definitions
        random.shuffle(options)
        correct_index = options.index(definition['definition'])
        
        return {
            "question": f"Que signifie '{definition['terme']}'?",
            "options": options,
            "correct": correct_index,
            "explication": f"'{definition['terme']}' {definition['definition']}"
        }

    def question_mot_cle_contexte(self, mots_cles, contenu):
        """Question sur l'utilisation d'un mot-clé"""
        if not mots_cles:
            return None
        
        mot = random.choice(mots_cles)
        phrases = [p.strip() for p in re.split(r'[.!?]+', contenu) if mot.lower() in p.lower()]
        
        if not phrases:
            return None
        
        phrase_vraie = phrases[0][:80] + "..." if len(phrases[0]) > 80 else phrases[0]
        
        fausses_phrases = [
            "Ce terme n'apparaît pas dans la note",
            "Il est mentionné seulement en conclusion",
            "Il est défini au début du texte"
        ]
        
        options = [phrase_vraie] + fausses_phrases
        random.shuffle(options)
        correct_index = options.index(phrase_vraie)
        
        return {
            "question": f"Comment le mot '{mot}' est-il utilisé dans le texte?",
            "options": options,
            "correct": correct_index,
            "explication": f"Le mot '{mot}' apparaît dans ce contexte."
        }

    def question_theme_principal(self, themes, contenu):
        """Question sur le thème principal"""
        if not themes:
            return None
        
        theme = random.choice(themes)
        faux_themes = ["analyse comparative", "étude historique", "recherche empirique"]
        
        options = [f"Le thème de '{theme['mot_cle']}'"] + [f"Le thème de '{t}'" for t in faux_themes]
        random.shuffle(options)
        correct_index = options.index(f"Le thème de '{theme['mot_cle']}'")
        
        return {
            "question": "Quel est l'un des thèmes abordés dans cette note?",
            "options": options,
            "correct": correct_index,
            "explication": f"Le thème '{theme['mot_cle']}' est effectivement abordé."
        }

    def question_relation_concepts(self, concepts, contenu):
        """Question sur la relation entre concepts"""
        if len(concepts) < 2:
            return None
        
        concept1, concept2 = random.sample(concepts, 2)
        
        # Vérifier s'ils apparaissent dans la même phrase
        phrases = re.split(r'[.!?]+', contenu)
        relation_trouvee = False
        
        for phrase in phrases:
            if concept1.lower() in phrase.lower() and concept2.lower() in phrase.lower():
                relation_trouvee = True
                break
        
        if relation_trouvee:
            options = [
                f"'{concept1}' et '{concept2}' sont liés",
                f"'{concept1}' s'oppose à '{concept2}'",
                f"'{concept1}' précède '{concept2}'",
                "Aucune relation mentionnée"
            ]
            correct_index = 0
            explication = f"'{concept1}' et '{concept2}' sont mentionnés ensemble dans le texte."
        else:
            options = [
                "Aucune relation directe mentionnée",
                f"'{concept1}' dépend de '{concept2}'",
                f"'{concept2}' est un type de '{concept1}'",
                f"'{concept1}' et '{concept2}' sont identiques"
            ]
            correct_index = 0
            explication = f"'{concept1}' et '{concept2}' n'ont pas de relation directe dans le texte."
        
        return {
            "question": f"Quelle relation existe entre '{concept1}' et '{concept2}'?",
            "options": options,
            "correct": correct_index,
            "explication": explication
        }

    def question_comprehension_phrase(self, phrases):
        """Question de compréhension d'une phrase"""
        if not phrases:
            return None
        
        phrase = random.choice([p for p in phrases if len(p.split()) > 8])
        if not phrase:
            return None
        
        # Prendre les premiers mots de la phrase
        debut_phrase = ' '.join(phrase.split()[:6]) + "..."
        
        faux_debuts = [
            "Cette analyse démontre que...",
            "Les résultats indiquent que...",
            "Il est important de noter..."
        ]
        
        options = [debut_phrase] + faux_debuts
        random.shuffle(options)
        correct_index = options.index(debut_phrase)
        
        return {
            "question": "Laquelle de ces phrases apparaît dans la note?",
            "options": options,
            "correct": correct_index,
            "explication": f"Cette phrase commence effectivement ainsi dans la note."
        }

    def question_application_concept(self, mots_cles, contenu):
        """Question sur l'application d'un concept"""
        if not mots_cles:
            return None
        
        concept = random.choice(mots_cles)
        
        applications = [
            f"Pour comprendre {concept}",
            f"Pour appliquer {concept}",
            f"Pour analyser {concept}",
            "Pour mémoriser le concept"
        ]
        
        # La première option est généralement correcte
        correct_index = random.randint(0, 2)  # Les 3 premières sont potentiellement correctes
        
        return {
            "question": f"Comment peut-on utiliser le concept de '{concept}'?",
            "options": applications,
            "correct": correct_index,
            "explication": f"Le concept de '{concept}' peut être utilisé de différentes manières selon le contexte."
        }

    def question_analyse_contenu(self, themes, phrases):
        """Question d'analyse du contenu"""
        if not themes or not phrases:
            return None
        
        nb_themes = len(themes)
        nb_phrases = len(phrases)
        
        options = [
            f"Traite {nb_themes} thèmes principaux",
            f"Contient {nb_themes * 2} thèmes principaux",
            "Se concentre sur un seul thème",
            "Aborde plus de 10 thèmes différents"
        ]
        
        return {
            "question": "Comment peut-on caractériser le contenu de cette note?",
            "options": options,
            "correct": 0,
            "explication": f"Cette note développe {nb_themes} thèmes principaux identifiés."
        }

    # CORRECTION 3: Système de quiz amélioré
    def config_quiz_dialog(self, *args):
        """Dialog pour configurer le quiz - CORRECTION"""
        if not self.note_actuelle:
            self.show_snackbar("Sélectionnez une note pour le quiz!")
            return
        
        content = MDBoxLayout(orientation="vertical", spacing="15dp", adaptive_height=True)
        
        instruction_label = MDLabel(
            text="Combien de questions voulez-vous?",
            font_style="Subtitle1"
        )
        content.add_widget(instruction_label)
        
        self.quiz_count_field = MDTextField(
            hint_text="Nombre de questions (1-10)",
            text="5",
            size_hint_y=None,
            height="48dp"
        )
        content.add_widget(self.quiz_count_field)
        
        self.dialog = MDDialog(
            title="Configuration Quiz",
            type="custom",
            content_cls=content,
            buttons=[
                MDRaisedButton(text="Annuler", on_release=self.close_dialog),
                MDRaisedButton(text="Démarrer Quiz", on_release=self.demarrer_quiz_configure)
            ]
        )
        self.dialog.open()

    def demarrer_quiz_configure(self, *args):
        """Démarre le quiz avec la configuration choisie"""
        try:
            nombre_questions = int(self.quiz_count_field.text.strip())
            if nombre_questions < 1 or nombre_questions > 10:
                self.show_snackbar("Choisissez entre 1 et 10 questions!")
                return
        except ValueError:
            self.show_snackbar("Entrez un nombre valide!")
            return
        
        self.quiz_nombre_questions = nombre_questions
        self.close_dialog()
        self.generer_quiz_ameliore()

    def generer_quiz_ameliore(self):
        """Génère un quiz intelligent basé sur l'analyse du contenu de la note"""
        contenu = self.note_actuelle['contenu']
        
        if len(contenu.split()) < 30:
            self.show_snackbar("La note doit contenir au moins 30 mots pour un quiz pertinent!")
            return
        
        # Analyser le contenu pour générer des questions pertinentes
        questions = []
        
        # Extraire les informations importantes
        mots_cles = self.extraire_mots_cles(contenu)
        themes = self.identifier_themes(contenu, re.split(r'[.!?]+', contenu))
        phrases = [p.strip() for p in re.split(r'[.!?]+', contenu) if len(p.strip()) > 15]
        definitions = self.extraire_definitions(contenu)
        concepts_importants = self.extraire_concepts_importants(contenu)
        
        # Types de questions intelligentes basées sur le contenu
        generateurs_questions = [
            lambda: self.question_definition_concept(definitions, mots_cles),
            lambda: self.question_mot_cle_contexte(mots_cles, contenu),
            lambda: self.question_theme_principal(themes, contenu),
            lambda: self.question_relation_concepts(concepts_importants, contenu),
            lambda: self.question_comprehension_phrase(phrases),
            lambda: self.question_application_concept(mots_cles, contenu),
            lambda: self.question_analyse_contenu(themes, phrases)
        ]
        
        # Générer le nombre de questions demandé
        questions_generees = 0
        tentatives = 0
        
        while questions_generees < self.quiz_nombre_questions and tentatives < 20:
            generateur = random.choice(generateurs_questions)
            question = generateur()
            
            if question and not self.question_existe_deja(question, questions):
                questions.append(question)
                questions_generees += 1
            
            tentatives += 1
        
        if not questions:
            self.show_snackbar("Impossible de générer des questions pertinentes pour cette note!")
            return
        
        self.quiz_questions = questions
        self.quiz_score = 0
        self.quiz_question_index = 0
        self.afficher_question_quiz()

    def afficher_question_quiz(self):
        """Affiche une question du quiz"""
        if self.quiz_question_index >= len(self.quiz_questions):
            self.terminer_quiz()
            return
        
        question = self.quiz_questions[self.quiz_question_index]
        
        content = MDBoxLayout(orientation="vertical", spacing="15dp", adaptive_height=True)
        
        # Question
        question_label = MDLabel(
            text=question["question"],
            font_style="H6",
            theme_text_color="Primary"
        )
        content.add_widget(question_label)
        
        # Options
        self.quiz_buttons = []
        for i, option in enumerate(question["options"]):
            btn = MDRaisedButton(
                text=f"{chr(65+i)}. {option}",
                size_hint_y=None,
                height="48dp"
            )
            btn.bind(on_release=lambda x, index=i: self.repondre_quiz(index))
            content.add_widget(btn)
            self.quiz_buttons.append(btn)
        
        # Progress
        progress_text = f"Question {self.quiz_question_index + 1}/{len(self.quiz_questions)}"
        progress_label = MDLabel(text=progress_text, font_style="Caption")
        content.add_widget(progress_label)
        
        self.dialog = MDDialog(
            title=f"Quiz: {self.note_actuelle['titre']}",
            type="custom",
            content_cls=content,
            auto_dismiss=False
        )
        self.dialog.open()

    def repondre_quiz(self, reponse_index):
        """Traite la réponse au quiz"""
        question = self.quiz_questions[self.quiz_question_index]
        correct = question["correct"]
        
        if reponse_index == correct:
            self.quiz_score += 1
            message = "Correct!"
        else:
            message = f"Incorrect. La bonne réponse était: {question['options'][correct]}"
        
        # Fermer le dialog actuel
        self.dialog.dismiss()
        
        # Afficher le résultat
        self.dialog = MDDialog(
            title=message,
            text=question["explication"],
            buttons=[
                MDRaisedButton(
                    text="SUIVANT",
                    on_release=self.question_suivante
                )
            ]
        )
        self.dialog.open()

    def question_suivante(self, *args):
        """Passe à la question suivante"""
        self.dialog.dismiss()
        self.quiz_question_index += 1
        self.afficher_question_quiz()

    def terminer_quiz(self):
        """Termine le quiz et affiche les résultats - AVEC ENREGISTREMENT STATISTIQUES"""
        pourcentage = (self.quiz_score / len(self.quiz_questions)) * 100
        
        # Enregistrer le score - MODIFICATION POUR STATISTIQUES
        if self.session_actuelle:
            matiere = self.session_actuelle['matiere']
            if matiere in self.matieres:
                score_data = {
                    'date': datetime.now().strftime("%Y-%m-%d %H:%M"),
                    'note_id': self.note_actuelle['id'],
                    'note_titre': self.note_actuelle['titre'],  # AJOUT DU TITRE
                    'score': self.quiz_score,
                    'total': len(self.quiz_questions),
                    'pourcentage': pourcentage
                }
                self.matieres[matiere]['quiz_scores'].append(score_data)
                
                if pourcentage >= 70:
                    self.matieres[matiere]['progression']['quiz_reussis'] += 1
        
        self.enregistrer_activite('quiz', f"Quiz terminé: {self.quiz_score}/{len(self.quiz_questions)}")
        
        # Déterminer le message selon le score
        if pourcentage >= 90:
            message = "Excellent!"
            encouragement = "Vous maîtrisez parfaitement le sujet!"
        elif pourcentage >= 70:
            message = "Très bien!"
            encouragement = "Bonne compréhension du sujet."
        elif pourcentage >= 50:
            message = "Peut mieux faire"
            encouragement = "Relisez la note pour améliorer votre compréhension."
        else:
            message = "À retravailler"
            encouragement = "Étudiez davantage cette note."
        
        self.dialog = MDDialog(
            title=f"Quiz Terminé - {message}",
            text=f"Score: {self.quiz_score}/{len(self.quiz_questions)} ({pourcentage:.1f}%)\n\n{encouragement}",
            buttons=[
                MDRaisedButton(text="RECOMMENCER", on_release=self.recommencer_quiz),
                MDRaisedButton(text="TERMINER", on_release=self.close_dialog)
            ]
        )
        self.dialog.open()
        
        self.save_data()
        self.update_evolution_panel()

    def recommencer_quiz(self, *args):
        """Recommence le quiz"""
        self.dialog.dismiss()
        self.quiz_score = 0
        self.quiz_question_index = 0
        self.afficher_question_quiz()

    def filter_notes(self, instance, text):
        """Filtre les notes - CORRECTION"""
        terme = text.lower().strip()
        
        if not terme:
            self.notes_filtrees = []
        else:
            self.notes_filtrees = [note for note in self.notes_liste 
                                 if terme in note['titre'].lower() or 
                                    terme in note['contenu'].lower()]
        
        self.update_notes_list()

    def effacer_recherche(self, *args):
        """Efface la recherche"""
        self.search_field.text = ""
        self.notes_filtrees = []
        self.update_notes_list()

    def supprimer_note_dialog(self, *args):
        """Dialog de suppression - CORRECTION"""
        if not self.note_actuelle:
            self.show_snackbar("Aucune note sélectionnée!")
            return
        
        self.dialog = MDDialog(
            title="Supprimer la note",
            text=f"Supprimer '{self.note_actuelle['titre']}'?\n\nCette action est irréversible.",
            buttons=[
                MDRaisedButton(text="ANNULER", on_release=self.close_dialog),
                MDRaisedButton(text="SUPPRIMER", on_release=self.confirm_delete_note)
            ]
        )
        self.dialog.open()

    def confirm_delete_note(self, *args):
        """Confirme la suppression"""
        if self.note_actuelle:
            titre_supprime = self.note_actuelle['titre']
            
            # Supprimer de la liste
            self.notes_liste = [note for note in self.notes_liste if note['id'] != self.note_actuelle['id']]
            
            # Réassigner les IDs pour éviter les gaps
            for i, note in enumerate(self.notes_liste):
                note['id'] = i + 1
            
            # Nettoyer l'interface
            self.title_field.text = ""
            self.content_field.text = ""
            self.note_actuelle = None
            
            # Mettre à jour et sauvegarder
            self.update_notes_list()
            self.save_data()
            self.show_snackbar(f"Note '{titre_supprime}' supprimée!")
        
        self.close_dialog()

    def partager_note_dialog(self, *args):
        """Dialog de partage"""
        if not self.note_actuelle:
            self.show_snackbar("Aucune note sélectionnée!")
            return
        
        content = MDBoxLayout(orientation="vertical", spacing="10dp", adaptive_height=True)
        
        self.share_email_field = MDTextField(hint_text="Email destinataire")
        content.add_widget(self.share_email_field)
        
        self.dialog = MDDialog(
            title="Partager la note",
            type="custom",
            content_cls=content,
            buttons=[
                MDRaisedButton(text="ANNULER", on_release=self.close_dialog),
                MDRaisedButton(text="PARTAGER", on_release=self.confirm_share_note)
            ]
        )
        self.dialog.open()

    def confirm_share_note(self, *args):
        """Confirme le partage"""
        email = self.share_email_field.text.strip()
        if email:
            self.show_snackbar(f"Note partagée avec {email}!")
            self.close_dialog()
        else:
            self.show_snackbar("Email requis!")

    # Rappels
    def update_reminders_list(self):
        """Met à jour la liste des rappels"""
        if not hasattr(self, 'reminders_list'):
            return
            
        self.reminders_list.clear_widgets()
        
        for rappel in self.rappels_liste:
            if rappel['actif']:
                item = TwoLineListItem(
                    text=rappel['titre'],
                    secondary_text=rappel['date_heure']
                )
                self.reminders_list.add_widget(item)

    def ajouter_rappel_dialog(self, *args):
        """Dialog pour ajouter un rappel"""
        content = MDBoxLayout(orientation="vertical", spacing="10dp", adaptive_height=True)
        
        self.reminder_title_field = MDTextField(hint_text="Titre du rappel")
        content.add_widget(self.reminder_title_field)
        
        self.reminder_date_field = MDTextField(
            hint_text="Date (YYYY-MM-DD)",
            text=datetime.now().strftime("%Y-%m-%d")
        )
        content.add_widget(self.reminder_date_field)
        
        self.reminder_time_field = MDTextField(
            hint_text="Heure (HH:MM)",
            text="09:00"
        )
        content.add_widget(self.reminder_time_field)
        
        self.dialog = MDDialog(
            title="Nouveau Rappel",
            type="custom",
            content_cls=content,
            buttons=[
                MDRaisedButton(text="ANNULER", on_release=self.close_dialog),
                MDRaisedButton(text="AJOUTER", on_release=self.save_reminder)
            ]
        )
        self.dialog.open()

    def save_reminder(self, *args):
        """Sauvegarde un rappel"""
        titre = self.reminder_title_field.text.strip()
        date_str = self.reminder_date_field.text.strip()
        heure_str = self.reminder_time_field.text.strip()
        
        if not titre:
            self.show_snackbar("Titre requis!")
            return
        
        try:
            date_heure = datetime.strptime(f"{date_str} {heure_str}", "%Y-%m-%d %H:%M")
            rappel = {
                'id': len(self.rappels_liste) + 1,
                'titre': titre,
                'date_heure': date_heure.strftime("%Y-%m-%d %H:%M"),
                'actif': True
            }
            self.rappels_liste.append(rappel)
            self.update_reminders_list()
            self.save_data()
            self.show_snackbar("Rappel ajouté!")
            self.close_dialog()
        except ValueError:
            self.show_snackbar("Format date/heure invalide!")

    # Sessions d'étude
    def demander_nouvelle_session(self, *args):
        """Dialog pour nouvelle session"""
        if self.session_actuelle:
            self.dialog = MDDialog(
                title="Session en cours",
                text="Une session est active. La terminer?",
                buttons=[
                    MDRaisedButton(text="NON", on_release=self.close_dialog),
                    MDRaisedButton(text="OUI", on_release=self.terminer_et_nouvelle_session)
                ]
            )
            self.dialog.open()
        else:
            self.show_session_dialog()

    def show_session_dialog(self):
        """Affiche le dialog de session"""
        content = MDBoxLayout(orientation="vertical", spacing="10dp", adaptive_height=True)
        
        self.session_subject_field = MDTextField(hint_text="Nom de la matière")
        content.add_widget(self.session_subject_field)
        
        self.dialog = MDDialog(
            title="Nouvelle Session",
            type="custom",
            content_cls=content,
            buttons=[
                MDRaisedButton(text="ANNULER", on_release=self.close_dialog),
                MDRaisedButton(text="DÉMARRER", on_release=self.start_session_from_dialog)
            ]
        )
        self.dialog.open()

    def start_session_from_dialog(self, *args):
        """Démarre session depuis dialog"""
        matiere = self.session_subject_field.text.strip()
        
        if not matiere:
            self.show_snackbar("Entrez le nom de la matière!")
            return
        
        note_id = None
        if self.note_actuelle:
            note_id = self.note_actuelle.get('id')
            self.associer_note_matiere(note_id, matiere)
        
        self.demarrer_session_etude(matiere, note_id)
        self.update_evolution_panel()
        self.close_dialog()
        self.show_snackbar(f"Session démarrée pour {matiere}!")

    def terminer_et_nouvelle_session(self, *args):
        """Termine session et en démarre une nouvelle"""
        self.terminer_session_etude()
        self.close_dialog()
        self.show_session_dialog()

    def demarrer_session_etude(self, matiere, note_id=None):
        """Démarre une session d'étude"""
        if self.session_actuelle:
            self.terminer_session_etude()
        
        self.session_actuelle = {
            'matiere': matiere,
            'note_id': note_id,
            'debut': datetime.now(),
            'activites': []
        }
        self.temps_debut_session = datetime.now()
        
        if matiere not in self.matieres:
            self.matieres[matiere] = {
                'notes_ids': [],
                'temps_total': 0,
                'sessions': 0,
                'quiz_scores': [],
                'derniere_session': None,
                'progression': {
                    'notes_creees': 0,
                    'quiz_reussis': 0,
                    'temps_moyen_session': 0
                }
            }
        
        self.update_session_interface()

    def terminer_session_etude(self, *args):
        """Termine la session actuelle"""
        if not self.session_actuelle:
            self.show_snackbar("Aucune session active!")
            return
        
        fin = datetime.now()
        duree = (fin - self.session_actuelle['debut']).total_seconds() / 60
        
        session_complete = {
            'date': self.session_actuelle['debut'].strftime("%Y-%m-%d %H:%M"),
            'matiere': self.session_actuelle['matiere'],
            'duree': round(duree, 1),
            'note_id': self.session_actuelle.get('note_id'),
            'activites': self.session_actuelle.get('activites', [])
        }
        
        self.sessions_etude.append(session_complete)
        
        matiere = self.session_actuelle['matiere']
        self.matieres[matiere]['temps_total'] += duree
        self.matieres[matiere]['sessions'] += 1
        self.matieres[matiere]['derniere_session'] = datetime.now().strftime("%Y-%m-%d")
        
        total_sessions = self.matieres[matiere]['sessions']
        if total_sessions > 0:
            self.matieres[matiere]['progression']['temps_moyen_session'] = self.matieres[matiere]['temps_total'] / total_sessions
        
        self.session_actuelle = None
        self.temps_debut_session = None
        
        self.save_data()
        self.update_session_interface()
        self.show_snackbar(f"Session terminée: {duree:.1f} min")

    def enregistrer_activite(self, type_activite, details=None):
        """Enregistre une activité"""
        if self.session_actuelle:
            activite = {
                'type': type_activite,
                'heure': datetime.now().strftime("%H:%M"),
                'details': details
            }
            self.session_actuelle['activites'].append(activite)

    def associer_note_matiere(self, note_id, matiere):
        """Associe une note à une matière"""
        if matiere not in self.matieres:
            self.matieres[matiere] = {
                'notes_ids': [],
                'temps_total': 0,
                'sessions': 0,
                'quiz_scores': [],
                'derniere_session': None,
                'progression': {
                    'notes_creees': 0,
                    'quiz_reussis': 0,
                    'temps_moyen_session': 0
                }
            }
        
        if note_id not in self.matieres[matiere]['notes_ids']:
            self.matieres[matiere]['notes_ids'].append(note_id)
            self.matieres[matiere]['progression']['notes_creees'] += 1

    def associer_note_dialogue(self, *args):
        """Dialog pour associer note à matière"""
        if not self.note_actuelle:
            self.show_snackbar("Sélectionnez une note!")
            return
        
        content = MDBoxLayout(orientation="vertical", spacing="10dp", adaptive_height=True)
        
        self.associate_subject_field = MDTextField(hint_text="Nom de la matière")
        content.add_widget(self.associate_subject_field)
        
        self.dialog = MDDialog(
            title="Associer à une matière",
            type="custom",
            content_cls=content,
            buttons=[
                MDRaisedButton(text="ANNULER", on_release=self.close_dialog),
                MDRaisedButton(text="ASSOCIER", on_release=self.confirm_associate_note)
            ]
        )
        self.dialog.open()

    def confirm_associate_note(self, *args):
        """Confirme l'association"""
        matiere = self.associate_subject_field.text.strip()
        if matiere and self.note_actuelle:
            self.associer_note_matiere(self.note_actuelle['id'], matiere)
            self.update_evolution_panel()
            self.show_snackbar(f"Note associée à {matiere}!")
        self.close_dialog()

    def update_session_interface(self):
        """Met à jour l'interface de session"""
        try:
            if hasattr(self, 'session_label'):
                if self.session_actuelle:
                    duree = (datetime.now() - self.temps_debut_session).total_seconds() / 60
                    self.session_label.text = f"Session: {self.session_actuelle['matiere']} ({duree:.0f} min)"
                else:
                    self.session_label.text = "Aucune session active"
        except:
            pass

    def update_evolution_panel(self):
        """Met à jour le panel d'évolution - AVEC STATISTIQUES QUIZ"""
        try:
            if not hasattr(self, 'temps_label'):
                return
                
            stats = self.calculer_statistiques_globales()
            self.temps_label.text = f"Temps total: {stats['temps_total_global']:.0f} min"
            self.sessions_label.text = f"Sessions: {stats['sessions_total']}"
            self.matieres_label.text = f"Matières: {stats['matieres_etudiees']}"
            
            # NOUVELLES STATISTIQUES QUIZ
            self.quiz_total_label.text = f"Quiz réalisés: {stats['quiz_total']}"
            self.quiz_moyenne_label.text = f"Moyenne quiz: {stats['moyenne_quiz_globale']:.1f}%"
            
            # Mettre à jour la liste des matières avec info quiz
            if hasattr(self, 'subjects_list'):
                self.subjects_list.clear_widgets()
                for matiere, data in self.matieres.items():
                    temps = data['temps_total']
                    nb_quiz = len(data['quiz_scores'])
                    moyenne_quiz = 0
                    if nb_quiz > 0:
                        moyenne_quiz = sum([q['pourcentage'] for q in data['quiz_scores']]) / nb_quiz
                    
                    item = ThreeLineListItem(
                        text=matiere,
                        secondary_text=f"Temps: {temps:.0f} min | Sessions: {data['sessions']}",
                        tertiary_text=f"Quiz: {nb_quiz} ({moyenne_quiz:.1f}% moy.)" if nb_quiz > 0 else "Aucun quiz"
                    )
                    self.subjects_list.add_widget(item)
        except Exception as e:
            print(f"Erreur update_evolution_panel: {e}")

    def calculer_statistiques_globales(self):
        """Calcule les statistiques globales - AVEC STATISTIQUES QUIZ"""
        stats = {
            'temps_total_global': 0,
            'sessions_total': len(self.sessions_etude),
            'matieres_etudiees': len(self.matieres),
            'notes_total': len(self.notes_liste),
            'quiz_total': sum(len(m['quiz_scores']) for m in self.matieres.values()),
            'moyenne_quiz_globale': 0,
            'matiere_preferee': None,
            'progression_semaine': self.calculer_progression_semaine()
        }
        
        for session in self.sessions_etude:
            stats['temps_total_global'] += session['duree']
        
        # CALCUL MOYENNE QUIZ GLOBALE
        tous_scores = []
        for matiere in self.matieres.values():
            tous_scores.extend([q['pourcentage'] for q in matiere['quiz_scores']])
        
        if tous_scores:
            stats['moyenne_quiz_globale'] = sum(tous_scores) / len(tous_scores)
        
        if self.matieres:
            stats['matiere_preferee'] = max(self.matieres.keys(), 
                                          key=lambda m: self.matieres[m]['temps_total'])
        
        return stats

    def calculer_progression_semaine(self):
        """Calcule la progression de la semaine - AVEC QUIZ"""
        maintenant = datetime.now()
        debut_semaine = maintenant - timedelta(days=maintenant.weekday())
        
        sessions_semaine = [s for s in self.sessions_etude 
                          if datetime.strptime(s['date'], "%Y-%m-%d %H:%M") >= debut_semaine]
        
        # CALCUL QUIZ DE LA SEMAINE
        quiz_semaine = 0
        for matiere in self.matieres.values():
            for quiz in matiere['quiz_scores']:
                if datetime.strptime(quiz['date'], "%Y-%m-%d %H:%M") >= debut_semaine:
                    quiz_semaine += 1
        
        return {
            'sessions': len(sessions_semaine),
            'temps': sum(s['duree'] for s in sessions_semaine),
            'matieres': len(set(s['matiere'] for s in sessions_semaine)),
            'quiz': quiz_semaine  # NOUVELLE STATISTIQUE
        }

    def afficher_statistiques(self, *args):
        """Affiche les statistiques détaillées - AVEC STATISTIQUES QUIZ COMPLÈTES"""
        if not self.notes_liste and not self.sessions_etude:
            self.show_snackbar("Aucune donnée disponible")
            return
        
        stats = self.calculer_statistiques_globales()
        
        # Note la plus longue
        note_plus_longue = ""
        if self.notes_liste:
            note_longue = max(self.notes_liste, key=lambda n: len(n['contenu']))
            note_plus_longue = f"Note la plus longue: {note_longue['titre']}"
        
        # Note la plus récente
        note_plus_recente = ""
        if self.notes_liste:
            note_recente = max(self.notes_liste, key=lambda n: n['date_creation'])
            note_plus_recente = f"Note récente: {note_recente['titre']}"
        
        # STATISTIQUES QUIZ DÉTAILLÉES
        meilleur_score = 0
        pire_score = 100
        quiz_par_matiere = {}
        
        for matiere, data in self.matieres.items():
            if data['quiz_scores']:
                scores = [q['pourcentage'] for q in data['quiz_scores']]
                quiz_par_matiere[matiere] = {
                    'nombre': len(scores),
                    'moyenne': sum(scores) / len(scores),
                    'meilleur': max(scores),
                    'pire': min(scores)
                }
                
                meilleur_score = max(meilleur_score, max(scores))
                pire_score = min(pire_score, min(scores))
        
        # Matière avec le meilleur score moyen
        meilleure_matiere_quiz = ""
        if quiz_par_matiere:
            meilleure_mat = max(quiz_par_matiere.keys(), 
                               key=lambda m: quiz_par_matiere[m]['moyenne'])
            meilleure_matiere_quiz = f"Meilleure matière (quiz): {meilleure_mat} ({quiz_par_matiere[meilleure_mat]['moyenne']:.1f}%)"
        
        stats_text = f"""Statistiques Globales:

📊 GÉNÉRAL:
• Total notes: {stats['notes_total']}
• Total sessions: {stats['sessions_total']}
• Temps total: {stats['temps_total_global']:.1f} min
• Matières étudiées: {stats['matieres_etudiees']}

🎯 QUIZ:
• Quiz réalisés: {stats['quiz_total']}
• Moyenne générale: {stats['moyenne_quiz_globale']:.1f}%"""

        if quiz_par_matiere:
            stats_text += f"""
• Meilleur score: {meilleur_score:.1f}%
• Score le plus faible: {pire_score:.1f}%
{meilleure_matiere_quiz}"""

        stats_text += f"""

📈 PROGRESSION CETTE SEMAINE:
• Sessions: {stats['progression_semaine']['sessions']}
• Temps: {stats['progression_semaine']['temps']:.1f} min
• Quiz: {stats['progression_semaine']['quiz']}

📚 DÉTAILS:
{note_plus_longue}
{note_plus_recente}"""

        # Créer contenu scrollable pour les statistiques longues
        content = MDBoxLayout(
            orientation="vertical", 
            spacing="10dp", 
            adaptive_height=True,
            size_hint_y=None
        )
        content.bind(minimum_height=content.setter('height'))
        
        # Scroll pour les statistiques
        stats_scroll = MDScrollView(
            size_hint=(1, None),
            height="400dp"
        )
        
        stats_label = MDLabel(
            text=stats_text,
            font_style="Body1",
            text_size=(None, None),
            valign="top",
            markup=False,
            size_hint_y=None
        )
        stats_label.text_size = (350, None)
        stats_label.bind(texture_size=stats_label.setter('size'))
        
        stats_scroll.add_widget(stats_label)
        content.add_widget(stats_scroll)
        
        # BOUTON POUR VOIR DÉTAILS PAR MATIÈRE
        if quiz_par_matiere:
            detail_btn = MDRaisedButton(
                text="Détails par matière",
                size_hint_y=None,
                height="48dp"
            )
            detail_btn.bind(on_release=lambda x: self.afficher_details_matieres(quiz_par_matiere))
            content.add_widget(detail_btn)
        
        self.dialog = MDDialog(
            title="Statistiques Complètes",
            type="custom",
            content_cls=content,
            size_hint=(0.9, 0.8),
            buttons=[MDRaisedButton(text="OK", on_release=self.close_dialog)]
        )
        self.dialog.open()

    def afficher_details_matieres(self, quiz_par_matiere):
        """Affiche les détails par matière - NOUVELLE FONCTIONNALITÉ"""
        self.close_dialog()
        
        content = MDBoxLayout(
            orientation="vertical", 
            spacing="10dp", 
            adaptive_height=True,
            size_hint_y=None
        )
        content.bind(minimum_height=content.setter('height'))
        
        # Scroll pour les détails
        details_scroll = MDScrollView(
            size_hint=(1, None),
            height="400dp"
        )
        
        details_list = MDList()
        
        for matiere, stats in quiz_par_matiere.items():
            # Informations générales de la matière
            matiere_data = self.matieres[matiere]
            
            detail_text = f"""📚 {matiere}
⏱️ Temps total: {matiere_data['temps_total']:.1f} min
📝 Sessions: {matiere_data['sessions']}
🎯 Quiz: {stats['nombre']}
📊 Moyenne: {stats['moyenne']:.1f}%
🏆 Meilleur: {stats['meilleur']:.1f}%
📉 Plus faible: {stats['pire']:.1f}%"""
            
            # Derniers quiz
            derniers_quiz = sorted(matiere_data['quiz_scores'], 
                                 key=lambda q: q['date'], reverse=True)[:3]
            
            if derniers_quiz:
                detail_text += "\n\n🕒 Derniers quiz:"
                for quiz in derniers_quiz:
                    titre_note = quiz.get('note_titre', 'Note inconnue')
                    detail_text += f"\n• {titre_note}: {quiz['score']}/{quiz['total']} ({quiz['pourcentage']:.1f}%)"
            
            item = MDCard(
                elevation=2,
                padding="15dp",
                size_hint_y=None,
                height="200dp"
            )
            
            card_label = MDLabel(
                text=detail_text,
                font_style="Body2",
                text_size=(None, None),
                valign="top",
                size_hint_y=None
            )
            card_label.text_size = (300, None)
            card_label.bind(texture_size=card_label.setter('size'))
            
            item.add_widget(card_label)
            details_list.add_widget(item)
        
        details_scroll.add_widget(details_list)
        content.add_widget(details_scroll)
        
        self.dialog = MDDialog(
            title="Détails par Matière",
            type="custom",
            content_cls=content,
            size_hint=(0.9, 0.8),
            buttons=[
                MDRaisedButton(text="RETOUR", on_release=lambda x: self.afficher_statistiques()),
                MDRaisedButton(text="FERMER", on_release=self.close_dialog)
            ]
        )
        self.dialog.open()

    def ouvrir_config_api(self, *args):
        """Ouvre la configuration API"""
        content = MDBoxLayout(orientation="vertical", spacing="10dp", adaptive_height=True)
        
        info_label = MDLabel(
            text="Entrez votre clé API Hugging Face pour activer les fonctions IA:",
            font_style="Body1"
        )
        content.add_widget(info_label)
        
        self.api_field = MDTextField(
            hint_text="Clé API Hugging Face",
            password=True,
            helper_text="Obtenez votre clé sur huggingface.co"
        )
        content.add_widget(self.api_field)
        
        if self.api_key:
            self.api_field.text = self.api_key
        
        self.dialog = MDDialog(
            title="Configuration API",
            type="custom",
            content_cls=content,
            buttons=[
                MDRaisedButton(text="ANNULER", on_release=self.close_dialog),
                MDRaisedButton(text="SAUVEGARDER", on_release=self.save_api_config)
            ]
        )
        self.dialog.open()

    def save_api_config(self, *args):
        """Sauvegarde la clé API"""
        self.api_key = self.api_field.text.strip()
        self.save_data()
        self.close_dialog()
        
        if self.api_key:
            self.show_snackbar("Clé API sauvegardée!")
        else:
            self.show_snackbar("Clé API effacée!")

    # Stockage
    def init_storage(self):
        """Initialise le stockage"""
        try:
            if platform == 'android':
                try:
                    from android.permissions import request_permissions, Permission
                    request_permissions([Permission.WRITE_EXTERNAL_STORAGE, Permission.READ_EXTERNAL_STORAGE])
                except:
                    pass
                
                try:
                    app_dir = "/storage/emulated/0/StudyHelper"
                    if not os.path.exists(app_dir):
                        os.makedirs(app_dir)
                    self.store = JsonStore(os.path.join(app_dir, 'studyhelper.json'))
                except:
                    self.store = JsonStore('studyhelper.json')
            else:
                app_dir = os.path.expanduser("~/StudyHelper")
                if not os.path.exists(app_dir):
                    os.makedirs(app_dir)
                self.store = JsonStore(os.path.join(app_dir, 'studyhelper.json'))
            
            self.load_data()
        except Exception as e:
            print(f"Erreur stockage: {e}")
            try:
                self.store = JsonStore('studyhelper_backup.json')
            except:
                self.store = None

    def save_data(self):
        """Sauvegarde les données"""
        if not self.store:
            return
        
        try:
            donnees = {
                'notes': self.notes_liste,
                'rappels': self.rappels_liste,
                'matieres': self.matieres,
                'sessions_etude': self.sessions_etude,
                'email_config': self.email_config,
                'api_key': self.api_key
            }
            
            self.store.put('app_data', **donnees)
        except Exception as e:
            print(f"Erreur sauvegarde: {e}")

    def load_data(self):
        """Charge les données"""
        if not self.store:
            return
        
        try:
            if self.store.exists('app_data'):
                data = self.store.get('app_data')
                self.notes_liste = data.get('notes', [])
                self.rappels_liste = data.get('rappels', [])
                self.matieres = data.get('matieres', {})
                self.sessions_etude = data.get('sessions_etude', [])
                self.email_config.update(data.get('email_config', {}))
                self.api_key = data.get('api_key', '')
        except Exception as e:
            print(f"Erreur chargement: {e}")

    # Utilitaires
    def show_snackbar(self, message):
        """Affiche un snackbar"""
        try:
            Snackbar(text=message, duration=3).open()
        except:
            print(f"Message: {message}")

    def close_dialog(self, *args):
        """Ferme le dialog"""
        if self.dialog:
            self.dialog.dismiss()
            self.dialog = None

    # Vérification rappels
    def verifier_rappels(self, dt):
        """Vérifie les rappels"""
        maintenant = datetime.now()
        
        for rappel in self.rappels_liste:
            if rappel['actif']:
                try:
                    date_rappel = datetime.strptime(rappel['date_heure'], "%Y-%m-%d %H:%M")
                    if date_rappel <= maintenant:
                        self.show_snackbar(f"Rappel: {rappel['titre']}")
                        rappel['actif'] = False
                except:
                    pass
        
        self.update_reminders_list()

    # Cycle de vie de l'app
    def on_start(self):
        """Au démarrage"""
        Clock.schedule_interval(self.verifier_rappels, 60)
        Clock.schedule_interval(lambda dt: self.update_session_interface(), 60)
        Clock.schedule_interval(lambda dt: self.save_data(), 300)

    def on_pause(self):
        """En pause"""
        self.save_data()
        return True

    def on_resume(self):
        """Reprise"""
        try:
            self.load_data()
            self.update_notes_list()
            self.update_reminders_list()
            self.update_evolution_panel()
        except:
            pass

    def on_stop(self):
        """Arrêt"""
        self.save_data()


# Point d'entrée
if __name__ == "__main__":
    StudyHelperApp().run()
